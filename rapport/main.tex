\documentclass[11pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[francais]{babel}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{graphicx}
\usepackage{helvet}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{url}
\usepackage{xcolor}

\renewcommand{\familydefault}{\sfdefault}

\author{Aurelien Havet}
\title{GÈnÈration d'instances de modËles d'une application Ruby on Rails}
\date{15/01/2015}

\begin{document}
\maketitle
\tableofcontents
\section{Introduction}
Dans l'ing√©nierie logicielle, les bugs sont l√©gions, et les rapports de crash sont des informations primordiales pour leurs r√©parations. Ils contiennent en particulier la pile d'appels de fonctions au moment du crash, dite stack trace, qui aide √† la compr√©hension du contexte dans lequel a lieu l'erreur. Il est utile dans ce cas de pouvoir trouver une source d'information au sujet d'un crash ayant une stack trace similaire et proposant une solution pour √©viter que le bug √† l'origine de ce crash ne se repoduise.

StackOverflow\cite{SO} est un site d√©di√© aux d√©veloppeurs. Construit sous forme de blog, il permet √† chacun de publier son probl√®me afin que d'autres y r√©pondent. S'il s'agit d'un bug logiciel, la stack trace correspondant √† celui-ci peut avoir √©t√© publi√©e afin que d'autres d√©veloppeurs puissent l'analyser et proposer une solution ad√©quate au probl√®me. Post apr√®s post, ce site est devenu une vraie mine d'informations sur les erreurs logicielles rencontr√©es par la communaut√© informatique. Pouvoir trouver une question, et √† post√©riori la solution associ√©e, se rapprochant au maximum d'un probl√®me rencontr√© par un d√©veloppeur, est pour ce dernier un v√©ritable gain de temps et de productivit√©.
\newline

Nous nous proposons ici de structurer et de stocker en base de donn√©es des stack traces extraites d'un dump des questions post√©es sur StackOverflow, afin de pouvoir en ressortir les candidates se rapprochant le plus d'une stack trace recherch√©e. L'id√©e est de pouvoir acc√©der de mani√®re efficace et pertinente aux questions semblables au probl√®me du d√©veloppeur, et donc aux r√©ponses propos√©es.

Ainsi, souhaitant √©tablir les similarit√©s entre diff√©rentes stack traces et donc mettre en exergue leurs points communs, nous avons mod√©lis√© celles-ci comme listes d'encha√Ænements de frames, une frame √©tant compos√©e d'une m√©thode, un nom de fichier et d'un num√©ro de ligne, et correspond textuellement √† une ligne de stack trace.

\section{Approche}

Le travail de d√©part consiste en l'extraction des donn√©es issues d'un dump de donn√©es de stackexchange librement accessible sur le site internet archive.org\cite{so-dump}.
Ces donn√©es repr√©sente l'ensembe des posts, tags et autre m√©ta-donn√©es produites par l'ensemble des sites h√©b√©rg√©s par la plateforme StackExchange\cite{se}.
Parmi ces sites, StackOverflow pr√©sente l'ensemble de ses posts (questions et r√©ponses) sous la forme d'un fichier XML d'une taille de 29 Go.
Son chargement complet en m√©moire sur un poste de travail moyen est donc exclu.
Afin de rendre la recherhe dans le data set possible, le contenu du fichier \texttt{Posts.xml} sera trait√© sous forme de flux.
Dans un premier temps, nous nous int√©ressons uniquement √† l'analyse des stack traces Java.
Son contenu sera alors filtr√© pour conserver les questions remplissant les crit√®res suivants:
\newline

\begin{itemize}
	\item Avoir une r√©ponse accept√©e
	\item Porter le tag Java
	\item Contenir au moins une stack trace Java\newline
\end{itemize}

Les donn√©es filtr√©es seront directement inject√©es dans une base de donn√©es MySQL en prenant soin de minimiser la redondance en base de donn√©es.
\subsection{Parsing}

Notre √©tude se porte donc en premier lieu sur l'analyse des stack traces Java.
Ayant √† notre disposition un parseur d√©velopp√© en Java adapt√© √† cette recherche, notre choix sur la technologie √† employer s'est naturellement orient√© vers ce langage.
\newline

Le document original contenant les postes √† traiter est une archive contenant un fichier XML.
Apr√®s d√©compression, ce fichier est d'une taille de 29 895 Mo.
Ce fichier est une suite de noeuds \texttt{<row>} (les posts) fils du noeud racine \texttt{<posts>}.
Sa taille se justifie par la pr√©sence de questions (bien ou mal formul√©es), de r√©ponses (pertinentes ou non) mais surtout de m√©ta-donn√©es, comme leur score, leur date de publication ou de derni√®re √©dition, ou encore l'identifiant de la r√©ponse s√©lectionn√©e quand il y en a une.
\newline

Notre travail portant sur l'analyse de stack traces Java, un filtrage simple peut √tre mis en place pour r√©duire le fichier √† une taille plus raisonable, et √©viter ainsi le traitement inutile d'un grand nombre de posts.
 un processeur de tag XML \texttt{XMLWriter}, proc√©dant √† la r√©√©criture d'un fichier XML en filtrant les noeuds qui ne nous int√©ressent pas.
Ce travail de r√©duction produit un fichier XML d'une taille bien plus modeste : 128 Mo.
\newline

Arriv√© √† ce point, il est interressant de constater qu'un chargement complet en m√©moire ne parait plus impossible.
Mais la taille d√©sormais abordable du fichier en entr√©e est un resultat direct des conditions de filtrage que nous avons mises en place.
Travailler √† extraire les donn√©es li√©es √† un langage potentiellement plus populaire, ou l'ouverture √† des posts autres que le questions, pourrait produire un fichier trop large pour envisager le chargement en RAM.
De plus, le traitement choisi pour ce projet porte principalement sur la transormation des donn√©es pour stockage dans une base de donn√©es SQL.
On peut donc profiter du processeur pour g√©n√©rer un fichier r√©duit comme base pour le travail de transformation, ou l'abandonner compl√®tement afin traiter le fichier original et stocker directement nos donn√©es en base.

\subsection{Structuration des donn√©es}

Afin de r√©pondre √† notre besoin de persistence des stack traces analys√©es, nous optons pour une base de donn√©es MySQL.
Ce choix nous est apparu comme judicieux pour sa simplicit√© et la connaissance que nous avons de cette technologie.
\newline

Deux types de donn√©es nous int√©ressent : les questions et leurs stack traces.
Afin d'apporter une forme de normalisation, une restructuration s'impose.
Si les posts peuvent √™tre conserv√©s d'un seul tenant, les stack traces ne sont finalement qu'une suite de frames li√©es entre elles.
En particulier, l'id√©e de conserver les encha√Ænements de frames permet de d√©tecter facilement les sous-suites communes entre diff√©rentes stack traces, telles des graphes ayant des chemins communs.
\newline

La figure \ref{fig:model} (page \pageref{fig:model}) illustre le mod√®le de donn√©es choisi pour le projet.
Une entit√© \texttt{Post} peut √™tre li√©e √† plusieurs entit√©s \texttt{Stack} : cette relation est mod√©lis√©e par une entit√© \texttt{PostStack} qui poss√®de √©galement comme attribut la position de l'entit√© \texttt{Stack} dans l'entit√© \texttt{Post}.
Une entit√© \texttt{Stack} quant √† elle se compose d'entit√©s \texttt{Link} qui repr√©sentent le passage d'une ligne de stack - fichier, fonction, ligne - √† une autre.
Une telle transition pouvant potentiellement se retrouver dans diff√©rentes stack traces, nous avons mod√©lis√© le lien entre une entit√© \texttt{Stack} et une entit√© \texttt{Link} par une relation ManyToMany.
Enfin, une entit√© \texttt{Link} se compose donc de deux entit√©s \texttt{Frame} : la parente et sa fille, lEn tout bout de cha√Æne de ce diagramme, nous avons une entit√© \texttt{Frame} repr√©sentant simplement une ligne de stack trace : un nom de fichier, le nom de la m√©thode appel√©e, et le num√©ro de ligne d'appel de la m√©thode pr√©c√©dente.
Enfin l'entit√© \texttt{PostAnswer} permet de lier une question √† ses r√©ponses, dans l'id√©e d'une futur fonctionnalit√© de recherche des r√©ponses associ√©es √† une stack trace, pour le d√©veloppement de laquelle nous n'avons pas eu le temps n√©cessaire.
\newline

Comme pour le parser, un processeur a √©t√© d√©velopp√© pour traiter les tags XML re√ßus (voir la classe \texttt{SQLProcessor}).
Deux versions du processeur ont √©t√© cr√©√©es.
Une premi√®re version se contentant d'ins√©rer chaques frames et links sans se soucier de la duplication.
Une seconde version, beaucoup plus lente, v√©rifie la pr√©sence d'une frame avant de proc√©der √† l'insertion, afin d'√©viter la duplication des donn√©es identiques, et √©galement de permettre une superposition de la repr√©sentation en m√©moire des stack traces ayant des √©l√©ments communs.
\newline


\section{R√©sultats}

\begin{figure}[h]
\label{tbl:mysql}
\center
\begin{tabular} {|r|r|r|r|r|r|r|}
\hline
\textendash   & Posts & Stack traces & Frames & Links   & Taille (en Mo) & Dump (en Mo) \\
\hline
Non normalis√© & 23090 & 29228        & 325329 & 296082  & 252 & 152\\
\hline
Normalis√©     & 23090 & 29228        & 99841  & 296082  & 255 & 133\\
\hline
\end{tabular}
\caption{Stockage en base de donn√©es MySQL}
\end{figure}

Le tableau de la figure \ref{tbl:mysql} pr√©sente l'occupation en base des donn√©es analys√©es pour 2 versions du programme.
La premi√®re version est une version non normalis√©e listant le nombre de posts, de stack traces et de liens stock√©s en base de donn√©es.

Entre ces deux versions, on constate une nette diminution du nombre de frames enregistr√©es, de l'ordre de 70\%.
L'objectif √©tant de minimiser la redondance et faciliter la recherche en base de donn√©es sur base des index et de cl√©s √©trang√®res, cette √©volution apparait comme un b√©n√©fice.

Nous nous attendions √©galement √† appr√©cier une diminution du nombre de links, ce qui n'est pas le cas ici.
Cette anomalie nous a permis de d√©celer un bug de notre impl√©mentation emp√™chant notre programme d'identifier les links d√©j√† pr√©sents en base.
Nous avons donc √©crit un test reproduisant ce bug, et fix√© celui-ci, mais n'avons malheureusement pas eu le temps n√©cessaire √† l'ex√©cution d'une nouvelle analyse de notre tas de donn√©es.

Les deux derni√®res colonnes pr√©sentent respectivement l'occupation une fois charg√© dans MySQL et la taille du fichier de dump SQL qui peut √™tre g√©n√©r√© √† la fin du travail.

Ici encore, le r√©sultat sur la taille de la base de donn√©es semble √©trange, mais nous l'expliquons par l'ajout de contraintes d'int√©grit√© entre nos tables avec l'utilisation de cl√©s √©trang√®res.
Celles-ci rajoute un co√ªt non n√©gligeable en terme de repr√©sentation en m√©moire (par la cr√©ation d'index entre les tables) et de performance en insertion (par la v√©rification des contraintes), mais promet de meilleures performances en s√©lection.
C'est d'ailleurs cette derni√®re que nous recherchons afin d'avoir un outil de recherche aussi efficace que possible.

Quant √† la taille du dump, le gain sur celle-ci aurait s√ªrement √©t√© plus appr√©ciable si il n'y avait pas eu de r√©plications des links.
\newline
 

\subsection{Exploitation des donn√©es}
Une fois les donn√©es import√©es en base de donn√©es, un certain nombre d'observations peuvent √™tre faites.
Ces observations portent principalement sur les stack traces elles-m√™mes.

On remarque que les stack traces enregistr√©es en base ont une longeur moyenne de 13,823 frames.
Cette longueur varie de 1 √† 382 frames.

\subsection{Recherche de stack traces}
Un des objectifs potentiels de notre travail est la recherche de stack traces parmis celles accumul√©es par traitement du dump de Stackoverflow.

Au moment de l'√©criture de ce rapport, il est possible de retrouver une stack trace entr√©e pr√©c√©demment en la fournissant en entr√©e au programme.
Une am√©lioration int√©ressante serait l'extension √† la recherche de sous-suites de frames similaires dans les stack traces.

\begin{lstlisting}[caption=Sortie du programme de recherche dans les posts, breaklines=true,frame = single]
http://stackoverflow.com/questions/6816	Class file name must end with .class exception in Java Search
\end{lstlisting}

Fournir cette base de donn√©es comme syst√®me de recherche en y branchant un frontend plus agr√©able, par le web par exemple, offirait donc une alternative int√©ressante √† la recherche purement textuelle disponible sur Stackoverflow, ou encore √† l'utilisation des moteurs de recherches ext√©rieurs comme Google.

\section{Am√©liorations possibles}

Trois axes d'am√©lioration sont envisageables afin d'obtenir des donn√©es plus fiables et plus rapidement :
\begin{enumerate}
\item La correction du parser
\item Le multi-threading de l'insertion en base de donn√©es
\item Optimisation de la base de don√©es\newline
\end{enumerate}

Une correction du parser permettrait d'obtenir de meilleur r√©sultat lors de l'interpr√©tation des frames.
En effet, les frames issues du dump proviennent d'entr√©e dans un champ de saisie libre, provoquant potentiellement la modification de la stack trace lors du formattage ou de l'√©dition du post.
Le premier changement qui pourrait √™tre apport√© serait une lecture plus efficace du num√©ro de ligne ou du nom du fichier lors de l'analyse de la frame.
Le parser utilis√© pour ce projet introduisant parfois des caract√®res venus d'autres lignes dans ces r√©ponses, r√©duisant √† chaque fois un peu plus les possibilit√©s de normalisation.
\newline

La seconde piste d'am√©lioration concerne le processus de transformation lui-m√™me qui souffre actuellement de sa lenteur.
En effet, le travail de stockage des 23 000 stack traces repr√©sente une ex√©cution de pr√®s de 12 heures sans normalisation.
La version normalis√©e double tout simplement le temps n√©cessaire en prenant un peu plus de 24 heures (89248884717900 ns) pour achever son √©xecution - une diff√©rence de performance sur l'insertion vraisemblablement imputable √† l'introduction des contraintes de cl√©s √©trang√®res, comme √©voqu√© pr√©c√©demment.

S√©parer les responsabilit√© de parsing du document original et du stockage est une premi√®re √©tape.
Placer les r√©sultats du parsing dans une file d'attente et laisser l'entit√© de stockage la vider r√©guli√®rement permettrait de lib√©rer le document √† parser.
Enfin, mulitplier le nombre d'entit√©s en charge du stockage en fonction de la capacit√© de la machine h√¥te acc√©l√®rerait de mani√®re significative le process.
Par soucis de simplicit√© et manque de temps, nous avons pr√©f√©r√© ne pas d√©l√©guer l'insertion en base de donn√©es √† plusieurs processus, √©vitant ainsi la complexification de l'impl√©mentation.
Il est √† noter qu'ex√©cuter ce programme sur une machine d√Æte rapide - √©quip√©e d'un disque dur SSD et bien fournie en RAM - permettrait d'obtenir des r√©sultats dans un temps plus raisonable.
\newline

Enfin, MySQL a √©t√© choisi comme premier choix pour sa facilit√© de maintenance.
Plus d'expertise dans l'optimisation du stockage et des requ√™tes sur ce SGBD aurait peut-√™tre permis d'atteindre de meilleures performances.
Le choix d'un autre SGBD, ou d'une base de donn√©es NoSQL comme CouchDB\cite{sql-vs-nosql}, pourrait √©galement permettre un gain de performances.

\section{Conclusion}
Nous avons ici r√©alis√© l'analyse d'une quantit√© d'informations d'assez grande taille - pr√®s de 30 Go de donn√©es organis√©es en XML - et d'une certaine h√©t√©rog√©n√©it√© - le corps de chaque post n'√©tant qu'une suite de caract√®res sans contrainte formelles - pour en tirer de l'information homog√®ne - pr√®s de 30000 stack traces formalis√©es et persist√©es.

Ce tas de donn√©es organis√©es ouvre, au-del√† des quelques statistiques pr√©sent√©es ici, des perspectives d'utilisation pour des recherches performantes de stack trace, ou de calcul de distance entre stack traces.

Notre impl√©mentation\cite{sources} permet √©galement d'envisager l'utilisation d'autres parsers, qui impl√©menteraient l'interface \texttt{StackTrackParserItf}, et qui seraient d√©di√©s √† la recherche de stack traces dans d'autres langages.

\bibliography{references}
\bibliographystyle{plain}
\end{document}
